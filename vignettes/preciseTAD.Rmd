---
title: "preciseTAD Vignette"
author:
- name: Spiro Stilianoudakis
  affiliation:
  - &1 Department of Biostatistics, Virginia Commonwealth University, Richmond, VA
- name: Mikhail Dozmorov
  affiliation:
  - *1
date: '`r format(Sys.Date(), "%B %e, %Y")`'
abstract: >
  Chromosome conformation capture combined with high-throughput 
  sequencing experiments (Hi-C) have revealed that chromatin undergoes layers of
  compaction through DNA looping and folding, forming dynamic 3D structures.
  Among these are Topologically Associating Domains (TADs), which are known to
  play critical roles in cell dynamics like gene regulation and cell 
  differentiation. Precise TAD mapping remains difficult, as it is strongly 
  reliant on Hi-C data resolution. Obtaining genome-wide chromatin interactions 
  at high-resolution is costly resulting in variability in true TAD boundary 
  location by TAD calling algorithms. To aid in the precise identification of 
  TAD boundaries we developed a machine learning framework that leverages the 
  spatial relationship of many high resolution ChIP-seq defined genomic 
  elements, coupled with density-based clustering  and scalable partitioning 
  techniques. Our framework precisely predicts chromosome-specific TAD 
  boundaries on multiple cell types. We show that known molecular drivers of 3D 
  chromatin including CTCF, RAD21, and SMC3 are more enriched at our predicted 
  TAD boundaries compared to the boundaries identified by the popular ARROWHEAD 
  TAD caller. Our results provide useful insights into the 3D organization of 
  the human genome.
package: preciseTAD
output:
    BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{preciseTAD}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
    chunk_output_type: console
bibliography: references.bib
---

```{r set-options, echo=FALSE, cache=FALSE}
options(width = 400)
```

# Introduction

`preciseTAD` is an R package designed to transform TAD-calling into a supervised machine learning framework. `preciseTAD` offers full functionality in building the data and selecting the best model for predicting TAD boundary regions. The functionality can be broken into 2 primary usages:

+ Model building, and
+ Precise TAD boundary prediction

The training/testing data used for modeling is represented as a matrix with rows being genomic regions, columns being genomic annotations, and the association values between them. 

To create the row-wise dimension of the data, `preciseTAD` uses *shifted binning*, a strategy for creating the dimensions of the data matrix used for modeling by segmenting the linear genome into nonoverlapping regions. To create shifted bins, chromosome-specific bins start at half of the resolution *r*, and continue in congruent intervals of length *r* until the end of the chromosome (*mod r* + *r/2*), using hg19 genomic coordinates. The shifted genomic bins, are then defined as boundary regions (*Y = 1*) if they contain a called TAD boundary, and non-boundary regions (*Y = 0*) otherwise, thus establishing the binary response vector (**Y**) used for classification. Intuitively, shifted bins are centered on borders between the original bins, thus capturing potential TAD boundaries. 

The column-wise dimension is formed by genomic annotations, such as transcription factor binding sites (TFBSs), histone modification marks, chromatin states. The *($log_{2}$) distances*, which enumerate the genomic distance from the center of each genomic bin to the center of the nearest ChIP-seq peak region of interest, are forming the feature space. Other feature type options include *binary overlaps*-an indicator for whether a ChIP-seq region overlaps with genomic bin, *count overlaps*-the number of overlaps in each bin, and *percent overlaps*-the percentage of overlap between any bin and the total width of all ChIP-seq regions overlapping it.

The customized training/testing data formation offered by `preciseTAD` allows users to implement whichever binary classification machine learning algorithm of their choice. Additionally, `preciseTAD` offers a built in function for performing a random forest (RF) model, while maintaining flexibility in tuning hyperparameters and applying feature reduction (see section 3.1.2-3.1.3). The primary inputs are the training and testing data, a list of hyperparameter values, the number of cross-validation folds to use (if a grid of hyperparameter values is provided), and the metric used for optimization. The output includes the model object (necessary for downstream prediction of boundaries), the variable importances, and a list of performance metrics when validating the model on the testing data (see Table 1).

The second usage of `preciseTAD` allows users to leverage a TAD boundary region classifier in order to more precisely predict the genomic coordinates of chromosome-specific TAD boundaries at base resolution (see section 3.2.1). To do so, `preciseTAD` combines novel density-based clustering and scalable data partitioning techniques to narrow regions of high predictibility to single base coordinates, enriched for known molecular drivers of 3D chromatin. First, the probability vector, $p_{n_{i}}$, is extracted ($n_{i}$ representing the length of chromosome $i$). Next, *DBSCAN* (Density-based Spatial Clustering of Applications with Noise) [@ester1996density; @hahsler2019dbscan] is applied to the matrix of pairwise genomic distances between bases with $p_{n_{i}} \ge t$, where $t$ is a threshold determined by the user. The resulting clusters of highly predictive bases identified by DBSCAN are termed *preciseTAD boundary regions* (PTBR). To precisely identify a single base among each PTBR, *preciseTAD* implements an extension of partitioning around medoids (PAM), known as CLARA (Clustering Large Applications) for better scaling and more computational efficiency [@rousseeuw1990finding]. The corresponding cluster medoid is defined as a *preciseTAD boundary point* (PTBP), making it the most representative and biologically meaningful base within each clustered PTBR. `preciseTAD` offers users the flexibility in predicting boundaries on entire chromosomes, or on specific subsections of chromosomes. In either case, the primary inputs are the model used to predict boundary regions and the threshold for determining PTBRs. The subsequent output includes each of the CTBPs, PTBPs, and PTBRs in a list format for direct comparison between `preciseTAD` and the corresponding called boundaries.

The following vignette illustrates a workflow for precisely predicting TAD boundaries using `preciseTAD`.

# Getting Started

## Installation

```{r, eval = FALSE, message=FALSE}
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("preciseTAD")
devtools::install_github("dozmorovlab/preciseTAD")
library(preciseTAD)
```

```{r, include=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(e1071)
library(preciseTAD)
```

# Implementation

## Model building

### Construction of the data matrix

`preciseTAD` requires users to supply "ground-truth" TADs to establish the response vector (**Y**). As an example, we consider TADs derived from the popular *ARROWHEAD* TAD-caller, a part of the juicebox suite of tools developed by Aiden Lab [@durand2016juicer]. To get called TADs, *ARROWHEAD* was implemented on the autosomal chromosomes using 5 kb GM12878 Hi-C data [@rao20143d] ([GSE63525](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE63525)). A tutorial for how to implement *ARROWHEAD* can be found [here](https://github.com/aidenlab/juicer/wiki/Arrowhead). An example of the first 3 columns of the resulting TAD coordinates is shown below.

```{r, warning = FALSE}
data("arrowhead_gm12878_5kb")
head(arrowhead_gm12878_5kb)
```

Users will then need to transform this TAD data into a GRanges object of unique boundary coordinates for a list of pre-specified chromosomes. This can be done using the `preciseTAD::extractBoundaries` function. Here we only extract boundaries for CHR1 and CHR22. We specify `preprocess=FALSE` because we are only interested in boundaries and not in filtering TADs by length. Lastly, we specify `resolution=5000` to match with the resolution that was used by *ARROWHEAD* (although this argument is ignored given that `preprocess=FALSE`). As can be seen below, there were a total of 1901 unique TAD boundaries reported by *ARROWHEAD* for chromosomes 1 and 22.

```{r, warning = FALSE, message = FALSE}
bounds <- extractBoundaries(domains.mat = arrowhead_gm12878_5kb, preprocess = FALSE, CHR = c("CHR1", "CHR22"), resolution = 5000)
# View unique boundaries
bounds
```

To identify genomic annotations best predictive of TAD boundaries, `preciseTAD` requires ChIP-seq defined functional genomic annotations to establish the feature space ($\textbf{X}=\{X_{1}, X_{2}, \cdots, X_{p} \}$). Cell line-specific ChIP-seq data can be downloaded from [ENCODE](https://www.encodeproject.org/chip-seq-matrix/?type=Experiment&replicates.library.biosample.donor.organism.scientific_name=Homo%20sapiens&assay_title=TF%20ChIP-seq&status=released) in the form of BED files. Once you have downloaded your preferred list of functional genomic annotations, store them in a specific file location (i.e. "./path/to/BEDfiles"). These files can then be converted into a GRangesList object and used for create the feature space using the `preciseTAD::bedToGRangesList` function. The `signal` argument refers to the column in the BED files containing peak signal strength values and is used to assign metadata to the corresponding GRanges (only necessary for downstream plotting). As an example, we have already provided a GRangesList object with 26 transcription factor binding sites (TFBS) specific to the GM12878 cell line. Once you load it in, you can see the list of transcription factors using the following commands.

```{r, warning = FALSE, message = FALSE}
# path <- "./path/to/BEDfiles"
# tfbsList <- bedToGRangesList(filepath=path, pattern = "*.bed", signal=4)

data("tfbsList")
names(tfbsList)
tfbsList
```

Now, using the "ground-truth" TAD boundaries and the following TFBS, we can build the data matrix that will be used for predictive modeling. The `preciseTAD::createTADdata` function can be used to create the training and testing data. Here, we specify to train on chromosome 1 and test on chromosome 22. Additionally, we specify `resolution = 5000` to construct 5kb shifted genomic bins (to match the resolution used to call the original TADs), `featureType = "distance"` for a ($log_2$) distance-type feature space, and `resampling = "rus"` to apply random under-sampling (RUS) on the training data to balance classes of TAD-boundary vs. nonTAD-boundary regions. We also specify a seed to ensure reproducibility when performing the resampling. The result is a list containing two data frames: (1) the resampled (if specified) training data, and (2) the testing data

```{r, eval=FALSE}
tadData <- createTADdata(bounds.GR = bounds,
                         resolution = 5000,
                         genomicElements.GR = tfbsList,
                         featureType = "distance",
                         resampling = "rus",
                         trainCHR = "CHR1",
                         predictCHR = "CHR22",
                         seed = 123)

# View subset of training data
tadData[[1]][1:5,1:4]

# View subset of testing data
tadData[[2]][1:5,1:4]
```

### Feature selection using recursive feature elimination

We can now implement our machine learning algorithm of choice to predict TAD-boundary regions. Here, we opt for the random forest algorithm for binary classification. `preciseTAD` offers functionality for performing recursive feature elimination (RFE) as a form of feature reduction through the use of the `preciseTAD::TADrfe` function, which is a wrapper for the `rfe` function in the `caret` package [@kuhn2012caret]. `preciseTAD::TADrfe` implements a random forest model on the best subset of features from 2 to the maximum number of features in the data by powers of 2, using 5-fold cross-validation. We specify accuracy as the performance metric. An example is shown below.

```{r, eval=FALSE}
rfe_res <- TADrfe(trainData = tadData[[1]],
                 tuneParams = list(ntree = 500, nodesize = 1),
                 cvFolds = 5,
                 cvMetric = "Accuracy",
                 verbose = TRUE,
                 seed = 123)

# View RFE performances
rfe_res[[1]]

# View the variable importances among top n features across each CV fold
head(rfe_res[[2]])
```

Results from recursive feature elimination indicate that model accuracy begins to stabilize when only considering the top 4 transcription factors for build random forest predictive models (Figure 1A). After aggregating the variable importances of the top 4 TFBS across each cross-fold we see that the top 4 most important TFBS in each of the 5 folds are the SMC3, RAD21, CTCF, and ZNF143 (Figure 1B). These are known components of the loop-extrusion model that has been proposed as a mechanism for the 3D architecture of the human genome [@sanborn2015chromatin; @fudenberg2016formation; @hansen2018recent]. 


![**Figure 1**. (A) Recursive feature elimination (RFE) indicates that preformances stabilize when only considering the top 4 most predictive transcription factor bindin sites (TFBS). (B) Aggregate mean variable importances (using mean decrease in accuracy) for the top 4 TFBS across each of the 5 cross-folds.](figures/fig1_vignette.png)


### Implementing a random forest for TAD boundary region prediction

Now that we have suitably reduced our feature space, we can implement a random forest algorithm built simply on the TFBS mentioned above (SMC3, RAD21, CTCF, and ZNF143). To do so, we can take advantage of the `preciseTAD::TADrandomForest` function, which is a wrapper of the `randomForest` package [@breiman2001random; @liaw2002classification]. We specify the training and testing data, the hyperparameter values, the number of cross-validation folds, the performance metric to consider (here, accuracy), the seed to initialize for reproducibility, an indicator for retaining the model object, an indicator for retaining variable importances, the variable importance measure to consifer (here, mean decrease in accuracy (MDA)), and an indicator for retaining model performances based on the test data. A list of model performances are provided in Table 1 and can be accessed by running `tadModel[[3]]`.

```{r, warning = FALSE, message = FALSE}
# Restrict the data matrix to include only SMC3, RAD21, CTCF, and ZNF143
tfbsList <- tfbsList[names(tfbsList) %in% c("Gm12878-Ctcf-Broad", 
                                            "Gm12878-Rad21-Haib",
                                            "Gm12878-Smc3-Sydh",
                                            "Gm12878-Znf143-Sydh")]
tadData <- createTADdata(bounds.GR = bounds,
                         resolution = 5000,
                         genomicElements.GR = tfbsList,
                         featureType = "distance",
                         resampling = "rus",
                         trainCHR = "CHR1",
                         predictCHR = "CHR22",
                         seed=123)

# Run RF
tadModel <- TADrandomForest(trainData = tadData[[1]],
                            testData = tadData[[2]],
                            tuneParams = list(mtry = 2,
                                              ntree = 500,
                                              nodesize = 1),
                            cvFolds = 3,
                            cvMetric = "Accuracy",
                            verbose = FALSE,
                            seed = 123,
                            model = TRUE,
                            importances = TRUE,
                            impMeasure = "MDA",
                            performances = TRUE)
```

```{r, warning = FALSE, message = FALSE}
# View model performances
kable(tadModel[[3]], caption = "List of model performances when validating an RF built on CHR1 on CHR22 test data.")
```

As you may know, there exist other machine learning binary classifiers that can be used in this setting. For example, suppose we opt to implement a support vector machine (SVM). This is easy enough to accomplish given that `preciseTAD::createTADdata` conveniently sets up the training and testing data sets. We use the `e1071` package to run the SVM with a radial kernal, cost = 1, and gamma = 0.5 using the example command below. We see that the accuracy from the SVM model is only 0.56, whereas the accuracy from our random forest was 0.69 (Table 1).

```{r, warning = FALSE, message = FALSE}
svmModel <- svm(y ~ ., data = tadData[[1]], kernel = "radial", cost = 1, gamma = 0.5)

svmPreds <- predict(svmModel, tadData[[2]][, -1], positive = "Yes")

# Ðœiew confusion matrix
table(svmPreds, tadData[[2]][, 1])
```

## Precise TAD boundary prediction

Recall that our model is classifying TAD boundary **regions**, in that each prediction refers to a genomic bin of width 5000 bases. To more precisely predict TAD boundary coordinates at base resolution, we can leverage our model through the use of the `preciseTAD::preciseTAD` function.  Conceptually, instead of genomic bins, we annotate each base with the selected genomic annotations and featureType, and apply our model on this annotation matrix to predict the probability of each base being a TAD boundary given the associated genomic annotations. To minimize computational costs, the base-level prediction should be performed on selected regions.

### Running preciseTAD

Suppose we want to use our model to precisely predict the TAD boundary coordinates for the 2Mb section of CHR22:25,500,000-27,500,000. To do so, we specify `chromCoords = list(25500000, 27500000)`. Additionally, we set a threshold of 1.0 for constructing PTBRs using `threshold = 1.0`. We also specify 100 random samples to be used in the partitioning of the pairwise genomic distances used by CLARA. For DBSCAN, we assign 5000 and 3 for the $\epsilon$ and *MinPts* parameters, respectively.

```{r, warning = FALSE, message = FALSE}
# Make sure the ground truth boundaries only include the CHR used to predict
bounds <- extractBoundaries(domains.mat = arrowhead_gm12878_5kb,
                              preprocess = FALSE,
                              CHR = "CHR22",
                              resolution = 5000)

# Run preciseTAD
pt <- preciseTAD(bounds.GR = bounds,
                genomicElements.GR = tfbsList,
                featureType = "distance",
                CHR = "CHR22",
                chromCoords = list(25500000, 27500000),
                tadModel = tadModel[[1]],
                threshold = 1.0,
                flank = NULL,
                verbose = FALSE,
                seed = 123,
                parallel = FALSE,
                cores = NULL,
                splits = NULL,
                DBSCAN = TRUE,
                DBSCAN_params = list(5000, 3),
                method.Clust = NULL,
                PTBR = TRUE,
                CLARA = TRUE,
                method.Dist = "euclidean",
                samples = 100,
                juicer = TRUE)

# View the results
pt
```

The output of `preciseTAD::preciseTAD` are contained in a list object with 3 elements. In order of the output the results include: 1) the called TAD boundary points (CTBP) for the specified CHR (within the given region if `chromCoord` is specified), 2) the predicted TAD boundary points (PTBP) made by preciseTAD, and 3) the predicted TAD boundary regions (PTBR) made by preciseTAD (if `PTBR=TRUE`). From the results above we see that there were 18 called TAD boundary points by *ARROWHEAD* in the given section of CHR22. However, `preciseTAD` yielded 13 predicted TAD boundary points.

### Using preciseTAD with Juicebox

Juicebox is an interface provided by Aiden Lab that allows for superimposing TAD boundary coordinates onto Hi-C contact maps. To visualize TADs, you must first select a Hi-C map. As an example, you can import the contact matrix for GM12878 derived by Rao et al. 2014 by choosing `File -> Open... -> Rao and Huntley et al. -> GM12878 -> in situ Mbol -> primary`. To format `preciseTAD` results to use in juicebox, you must make sure to set `juicer=TRUE` in the function, as seen in Section 3.2.1. Otherwise, the resulting PTBPs (`pt[[2]]`) will be a `GRanges` object, similar to the CTBPs (`pt[[1]]`) and PTBRs (`pt[[3]]`). You will then need to save the PTBPs as a txt file using `write.table` as shown below. Once saved, import them into juicebox using `Show Annotation Panel -> 2D Annotations -> Add Local -> myPTBPs.txt`.

```{r, eval=FALSE, warning=FALSE, message=FALSE}
pt_chr22_255mb_275mb <- pt[[2]]
filepath = "~/path/to/store/ptbps/"
write.table(pt_chr22_255mb_275mb, 
            paste0(filepath, "pt_chr22_255mb_275mb.txt"),
            quote = FALSE,
            col.names = FALSE,
            row.names = FALSE,
            sep = "\t")
```

# References
